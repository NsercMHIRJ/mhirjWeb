{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst stringify_1 = require(\"./stringify\");\n\nconst quote_1 = require(\"./quote\");\n/**\n * Root path node.\n */\n\n\nconst ROOT_SENTINEL = Symbol(\"root\");\n/**\n * Stringify any JavaScript value.\n */\n\nfunction stringify(value, replacer, indent, options = {}) {\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path = [];\n  const stack = new Set();\n  const tracking = new Map();\n  const unpack = new Map();\n  let valueCount = 0;\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000\n  } = options; // Wrap replacer function to support falling back on supported stringify.\n\n  const valueToString = replacerToString(replacer); // Every time you call `next(value)` execute this function.\n\n  const onNext = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return; // An undefined key is treated as an out-of-band \"value\".\n\n    if (key === undefined) return valueToString(value, space, onNext, key);\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  const builder = references ? (value, key) => {\n    if (value !== null && (typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\")) {\n      // Track nodes to restore later.\n      if (tracking.has(value)) {\n        unpack.set(path.slice(1), tracking.get(value));\n        return; // Avoid serializing referenced nodes on an expression.\n      } // Track encountered nodes.\n\n\n      tracking.set(value, path.slice(1));\n    }\n\n    return valueToString(value, space, onNext, key);\n  } : (value, key) => {\n    // Stop on recursion.\n    if (stack.has(value)) return;\n    stack.add(value);\n    const result = valueToString(value, space, onNext, key);\n    stack.delete(value);\n    return result;\n  };\n  const result = onNext(value, ROOT_SENTINEL); // Attempt to restore circular references.\n\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = quote_1.stringifyPath(key, onNext);\n      const valuePath = quote_1.stringifyPath(value, onNext);\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n\n  return result;\n}\n\nexports.stringify = stringify;\n/**\n * Create `toString()` function from replacer.\n */\n\nfunction replacerToString(replacer) {\n  if (!replacer) return stringify_1.toString;\n  return (value, space, next, key) => {\n    return replacer(value, space, value => stringify_1.toString(value, space, next, key), key);\n  };\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { toString } from \"./stringify\";\nimport { stringifyPath } from \"./quote\";\nimport { Next, ToString } from \"./types\";\n\nexport interface Options {\n  maxDepth?: number;\n  maxValues?: number;\n  references?: boolean;\n  skipUndefinedProperties?: boolean;\n}\n\n/**\n * Root path node.\n */\nconst ROOT_SENTINEL = Symbol(\"root\");\n\n/**\n * Stringify any JavaScript value.\n */\nexport function stringify(\n  value: any,\n  replacer?: ToString | null,\n  indent?: string | number | null,\n  options: Options = {}\n) {\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path: PropertyKey[] = [];\n  const stack = new Set();\n  const tracking = new Map<any, PropertyKey[]>();\n  const unpack = new Map<PropertyKey[], PropertyKey[]>();\n  let valueCount = 0;\n\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000\n  } = options;\n\n  // Wrap replacer function to support falling back on supported stringify.\n  const valueToString = replacerToString(replacer);\n\n  // Every time you call `next(value)` execute this function.\n  const onNext: Next = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return;\n\n    // An undefined key is treated as an out-of-band \"value\".\n    if (key === undefined) return valueToString(value, space, onNext, key);\n\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  const builder: Next = references\n    ? (value, key) => {\n        if (\n          value !== null &&\n          (typeof value === \"object\" ||\n            typeof value === \"function\" ||\n            typeof value === \"symbol\")\n        ) {\n          // Track nodes to restore later.\n          if (tracking.has(value)) {\n            unpack.set(path.slice(1), tracking.get(value)!);\n            return; // Avoid serializing referenced nodes on an expression.\n          }\n\n          // Track encountered nodes.\n          tracking.set(value, path.slice(1));\n        }\n\n        return valueToString(value, space, onNext, key);\n      }\n    : (value, key) => {\n        // Stop on recursion.\n        if (stack.has(value)) return;\n\n        stack.add(value);\n        const result = valueToString(value, space, onNext, key);\n        stack.delete(value);\n        return result;\n      };\n\n  const result = onNext(value, ROOT_SENTINEL);\n\n  // Attempt to restore circular references.\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = stringifyPath(key, onNext);\n      const valuePath = stringifyPath(value, onNext);\n\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n\n  return result;\n}\n\n/**\n * Create `toString()` function from replacer.\n */\nfunction replacerToString(replacer?: ToString | null): ToString {\n  if (!replacer) return toString;\n\n  return (value, space, next, key) => {\n    return replacer(\n      value,\n      space,\n      (value: any) => toString(value, space, next, key),\n      key\n    );\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}