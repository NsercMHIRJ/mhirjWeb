{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst quote_1 = require(\"./quote\");\n/**\n * Used in function stringification.\n */\n\n/* istanbul ignore next */\n\n\nconst METHOD_NAMES_ARE_QUOTED = {\n  \" \"() {\n    /* Empty. */\n  }\n\n}[\" \"].toString().charAt(0) === '\"';\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\nconst TOKENS_PRECEDING_REGEXPS = new Set((\"case delete else in instanceof new return throw typeof void \" + \", ; : + - ! ~ & | ^ * / % < > ? =\").split(\" \"));\n/**\n * Track function parser usage.\n */\n\nexports.USED_METHOD_KEY = new WeakSet();\n/**\n * Stringify a function.\n */\n\nexports.functionToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined; // Track in function parser for object stringify to avoid duplicate output.\n\n  if (name !== undefined) exports.USED_METHOD_KEY.add(fn);\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\n\n\nfunction dedentFunction(fnString) {\n  let found;\n\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n\n    const [str] = m;\n    if (found === undefined) found = str;else if (str.length < found.length) found = str;\n  }\n\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\n\nexports.dedentFunction = dedentFunction;\n/**\n * Function parser and stringify.\n */\n\nclass FunctionParser {\n  constructor(fn, indent, next, key) {\n    this.fn = fn;\n    this.indent = indent;\n    this.next = next;\n    this.key = key;\n    this.pos = 0;\n    this.hadKeyword = false;\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name;\n    this.keyQuote = key === undefined ? \"\" : quote_1.quoteKey(key, next);\n    this.keyPrefix = key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate = key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  stringify() {\n    const value = this.tryParse(); // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n\n    return dedentFunction(value);\n  }\n\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    } // Attempt to remove function prefix.\n\n\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    } // Support class expressions.\n\n\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n      let offset = this.pos;\n\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n\n        // tslint:disable-next-line no-switch-case-fall-through\n\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n\n          this.pos = offset;\n        // tslint:disable-next-line no-switch-case-fall-through\n\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n\n\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n\n      if (this.consumeSyntax() === \"()\" && this.consumeSyntax() === \"{}\" && this.pos === this.fnString.length) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n\n    this.pos = start;\n  }\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   *\n   * @return {boolean}\n   */\n\n\n  tryParsePrefixTokens() {\n    let posPrev = this.pos;\n    this.hadKeyword = false;\n\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n        posPrev = this.pos;\n      // tslint:disable-next-line no-switch-case-fall-through\n\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n\n        return true;\n\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n      // tslint:disable-next-line no-switch-case-fall-through\n\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n\n        return token === \"*\";\n    }\n  }\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multicharacter operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multicharacter sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n\n\n  consumeSyntax(wordLikeToken) {\n    const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/);\n    if (!m) return;\n    const [token, match] = m;\n    this.consumeWhitespace();\n    if (match) return wordLikeToken || match;\n\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n\n      case \"`\":\n        return this.consumeTemplate();\n\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n\n    return token;\n  }\n\n  consumeSyntaxUntil(startToken, endToken) {\n    let isRegExpAllowed = true;\n\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n      if (token === \"/\" && isRegExpAllowed && this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n\n  consumeMatch(re) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n\n\n  consumeRegExp(re, token) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n  /**\n   * Advance the parser past a template string.\n   */\n\n\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n\n      return;\n    }\n  }\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n\n\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n\n}\n\nexports.FunctionParser = FunctionParser;","map":{"version":3,"sources":["../src/function.ts"],"names":[],"mappings":"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","sourcesContent":["import { Next, ToString } from \"./types\";\nimport { quoteKey, isValidVariableName } from \"./quote\";\n\n/**\n * Used in function stringification.\n */\n/* istanbul ignore next */\nconst METHOD_NAMES_ARE_QUOTED =\n  {\n    \" \"() {\n      /* Empty. */\n    }\n  }[\" \"]\n    .toString()\n    .charAt(0) === '\"';\n\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\n\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\n\nconst TOKENS_PRECEDING_REGEXPS = new Set(\n  (\n    \"case delete else in instanceof new return throw typeof void \" +\n    \", ; : + - ! ~ & | ^ * / % < > ? =\"\n  ).split(\" \")\n);\n\n/**\n * Track function parser usage.\n */\nexport const USED_METHOD_KEY = new WeakSet<Function>();\n\n/**\n * Stringify a function.\n */\nexport const functionToString: ToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined;\n\n  // Track in function parser for object stringify to avoid duplicate output.\n  if (name !== undefined) USED_METHOD_KEY.add(fn);\n\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\nexport function dedentFunction(fnString: string) {\n  let found: string | undefined;\n\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n\n    const [str] = m;\n\n    if (found === undefined) found = str;\n    else if (str.length < found.length) found = str;\n  }\n\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\n\n/**\n * Function parser and stringify.\n */\nexport class FunctionParser {\n  fnString: string;\n  fnType: keyof typeof FUNCTION_PREFIXES;\n  keyQuote: string | undefined;\n  keyPrefix: string;\n  isMethodCandidate: boolean;\n\n  pos = 0;\n  hadKeyword = false;\n\n  constructor(\n    public fn: Function,\n    public indent: string,\n    public next: Next,\n    public key?: string\n  ) {\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name as keyof typeof FUNCTION_PREFIXES;\n    this.keyQuote = key === undefined ? \"\" : quoteKey(key, next);\n    this.keyPrefix =\n      key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate =\n      key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  stringify() {\n    const value = this.tryParse();\n\n    // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n\n    return dedentFunction(value);\n  }\n\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    }\n\n    // Attempt to remove function prefix.\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    }\n\n    // Support class expressions.\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n\n      let offset = this.pos;\n\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n        // tslint:disable-next-line no-switch-case-fall-through\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n\n          this.pos = offset;\n        // tslint:disable-next-line no-switch-case-fall-through\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n\n      if (\n        this.consumeSyntax() === \"()\" &&\n        this.consumeSyntax() === \"{}\" &&\n        this.pos === this.fnString.length\n      ) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n\n    this.pos = start;\n  }\n\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   *\n   * @return {boolean}\n   */\n  tryParsePrefixTokens() {\n    let posPrev = this.pos;\n\n    this.hadKeyword = false;\n\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n\n        posPrev = this.pos;\n      // tslint:disable-next-line no-switch-case-fall-through\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n        return true;\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n      // tslint:disable-next-line no-switch-case-fall-through\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n\n        return token === \"*\";\n    }\n  }\n\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multicharacter operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multicharacter sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n  consumeSyntax(wordLikeToken?: string) {\n    const m = this.consumeMatch(\n      /^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/\n    );\n\n    if (!m) return;\n\n    const [token, match] = m;\n    this.consumeWhitespace();\n\n    if (match) return wordLikeToken || match;\n\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n      case \"`\":\n        return this.consumeTemplate();\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n\n    return token;\n  }\n\n  consumeSyntaxUntil(startToken: string, endToken: string): string | undefined {\n    let isRegExpAllowed = true;\n\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n      if (\n        token === \"/\" &&\n        isRegExpAllowed &&\n        this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)\n      ) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n\n  consumeMatch(re: RegExp) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n  consumeRegExp(re: RegExp, token: string): string | undefined {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n\n  /**\n   * Advance the parser past a template string.\n   */\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n\n      return;\n    }\n  }\n\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}