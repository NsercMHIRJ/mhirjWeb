{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/kanu/Desktop/MHIRJTEST/mhirjWeb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/kanu/Desktop/MHIRJTEST/mhirjWeb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/Users/kanu/Desktop/MHIRJTEST/mhirjWeb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/kanu/Desktop/MHIRJTEST/mhirjWeb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar quote_1 = require(\"./quote\");\n/**\n * Used in function stringification.\n */\n\n/* istanbul ignore next */\n\n\nvar METHOD_NAMES_ARE_QUOTED = {\n  \" \": function _() {\n    /* Empty. */\n  }\n}[\" \"].toString().charAt(0) === '\"';\nvar FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\nvar METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\nvar TOKENS_PRECEDING_REGEXPS = new Set((\"case delete else in instanceof new return throw typeof void \" + \", ; : + - ! ~ & | ^ * / % < > ? =\").split(\" \"));\n/**\n * Track function parser usage.\n */\n\nexports.USED_METHOD_KEY = new WeakSet();\n/**\n * Stringify a function.\n */\n\nexports.functionToString = function (fn, space, next, key) {\n  var name = typeof key === \"string\" ? key : undefined; // Track in function parser for object stringify to avoid duplicate output.\n\n  if (name !== undefined) exports.USED_METHOD_KEY.add(fn);\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\n\n\nfunction dedentFunction(fnString) {\n  var found;\n\n  var _iterator = _createForOfIteratorHelper(fnString.split(\"\\n\").slice(1)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n      var m = /^[\\s\\t]+/.exec(line);\n      if (!m) return fnString; // Early exit without indent.\n\n      var _m = _slicedToArray(m, 1),\n          str = _m[0];\n\n      if (found === undefined) found = str;else if (str.length < found.length) found = str;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return found ? fnString.split(\"\\n\".concat(found)).join(\"\\n\") : fnString;\n}\n\nexports.dedentFunction = dedentFunction;\n/**\n * Function parser and stringify.\n */\n\nvar FunctionParser = /*#__PURE__*/function () {\n  function FunctionParser(fn, indent, next, key) {\n    _classCallCheck(this, FunctionParser);\n\n    this.fn = fn;\n    this.indent = indent;\n    this.next = next;\n    this.key = key;\n    this.pos = 0;\n    this.hadKeyword = false;\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name;\n    this.keyQuote = key === undefined ? \"\" : quote_1.quoteKey(key, next);\n    this.keyPrefix = key === undefined ? \"\" : \"\".concat(this.keyQuote, \":\").concat(indent ? \" \" : \"\");\n    this.isMethodCandidate = key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  _createClass(FunctionParser, [{\n    key: \"stringify\",\n    value: function stringify() {\n      var value = this.tryParse(); // If we can't stringify this function, return a void expression; for\n      // bonus help with debugging, include the function as a string literal.\n\n      if (!value) {\n        return \"\".concat(this.keyPrefix, \"void \").concat(this.next(this.fnString));\n      }\n\n      return dedentFunction(value);\n    }\n  }, {\n    key: \"getPrefix\",\n    value: function getPrefix() {\n      if (this.isMethodCandidate && !this.hadKeyword) {\n        return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n      }\n\n      return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n    }\n  }, {\n    key: \"tryParse\",\n    value: function tryParse() {\n      if (this.fnString[this.fnString.length - 1] !== \"}\") {\n        // Must be an arrow function.\n        return this.keyPrefix + this.fnString;\n      } // Attempt to remove function prefix.\n\n\n      if (this.fn.name) {\n        var result = this.tryStrippingName();\n        if (result) return result;\n      } // Support class expressions.\n\n\n      var prevPos = this.pos;\n      if (this.consumeSyntax() === \"class\") return this.fnString;\n      this.pos = prevPos;\n\n      if (this.tryParsePrefixTokens()) {\n        var _result = this.tryStrippingName();\n\n        if (_result) return _result;\n        var offset = this.pos;\n\n        switch (this.consumeSyntax(\"WORD_LIKE\")) {\n          case \"WORD_LIKE\":\n            if (this.isMethodCandidate && !this.hadKeyword) {\n              offset = this.pos;\n            }\n\n          // tslint:disable-next-line no-switch-case-fall-through\n\n          case \"()\":\n            if (this.fnString.substr(this.pos, 2) === \"=>\") {\n              return this.keyPrefix + this.fnString;\n            }\n\n            this.pos = offset;\n          // tslint:disable-next-line no-switch-case-fall-through\n\n          case '\"':\n          case \"'\":\n          case \"[]\":\n            return this.getPrefix() + this.fnString.substr(this.pos);\n        }\n      }\n    }\n    /**\n     * Attempt to parse the function from the current position by first stripping\n     * the function's name from the front. This is not a fool-proof method on all\n     * JavaScript engines, but yields good results on Node.js 4 (and slightly\n     * less good results on Node.js 6 and 8).\n     */\n\n  }, {\n    key: \"tryStrippingName\",\n    value: function tryStrippingName() {\n      if (METHOD_NAMES_ARE_QUOTED) {\n        // ... then this approach is unnecessary and yields false positives.\n        return;\n      }\n\n      var start = this.pos;\n      var prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n      if (prefix === this.fn.name) {\n        this.pos += prefix.length;\n\n        if (this.consumeSyntax() === \"()\" && this.consumeSyntax() === \"{}\" && this.pos === this.fnString.length) {\n          // Don't include the function's name if it will be included in the\n          // prefix, or if it's invalid as a name in a function expression.\n          if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {\n            start += prefix.length;\n          }\n\n          return this.getPrefix() + this.fnString.substr(start);\n        }\n      }\n\n      this.pos = start;\n    }\n    /**\n     * Attempt to advance the parser past the keywords expected to be at the\n     * start of this function's definition. This method sets `this.hadKeyword`\n     * based on whether or not a `function` keyword is consumed.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"tryParsePrefixTokens\",\n    value: function tryParsePrefixTokens() {\n      var posPrev = this.pos;\n      this.hadKeyword = false;\n\n      switch (this.fnType) {\n        case \"AsyncFunction\":\n          if (this.consumeSyntax() !== \"async\") return false;\n          posPrev = this.pos;\n        // tslint:disable-next-line no-switch-case-fall-through\n\n        case \"Function\":\n          if (this.consumeSyntax() === \"function\") {\n            this.hadKeyword = true;\n          } else {\n            this.pos = posPrev;\n          }\n\n          return true;\n\n        case \"AsyncGeneratorFunction\":\n          if (this.consumeSyntax() !== \"async\") return false;\n        // tslint:disable-next-line no-switch-case-fall-through\n\n        case \"GeneratorFunction\":\n          var token = this.consumeSyntax();\n\n          if (token === \"function\") {\n            token = this.consumeSyntax();\n            this.hadKeyword = true;\n          }\n\n          return token === \"*\";\n      }\n    }\n    /**\n     * Advance the parser past one element of JavaScript syntax. This could be a\n     * matched pair of delimiters, like braces or parentheses, or an atomic unit\n     * like a keyword, variable, or operator. Return a normalized string\n     * representation of the element parsed--for example, returns '{}' for a\n     * matched pair of braces. Comments and whitespace are skipped.\n     *\n     * (This isn't a full parser, so the token scanning logic used here is as\n     * simple as it can be. As a consequence, some things that are one token in\n     * JavaScript, like decimal number literals or most multicharacter operators\n     * like '&&', are split into more than one token here. However, awareness of\n     * some multicharacter sequences like '=>' is necessary, so we match the few\n     * of them that we care about.)\n     */\n\n  }, {\n    key: \"consumeSyntax\",\n    value: function consumeSyntax(wordLikeToken) {\n      var m = this.consumeMatch(/^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/);\n      if (!m) return;\n\n      var _m2 = _slicedToArray(m, 2),\n          token = _m2[0],\n          match = _m2[1];\n\n      this.consumeWhitespace();\n      if (match) return wordLikeToken || match;\n\n      switch (token) {\n        case \"(\":\n          return this.consumeSyntaxUntil(\"(\", \")\");\n\n        case \"[\":\n          return this.consumeSyntaxUntil(\"[\", \"]\");\n\n        case \"{\":\n          return this.consumeSyntaxUntil(\"{\", \"}\");\n\n        case \"`\":\n          return this.consumeTemplate();\n\n        case '\"':\n          return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n\n        case \"'\":\n          return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n      }\n\n      return token;\n    }\n  }, {\n    key: \"consumeSyntaxUntil\",\n    value: function consumeSyntaxUntil(startToken, endToken) {\n      var isRegExpAllowed = true;\n\n      for (;;) {\n        var token = this.consumeSyntax();\n        if (token === endToken) return startToken + endToken;\n        if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n        if (token === \"/\" && isRegExpAllowed && this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)) {\n          isRegExpAllowed = false;\n          this.consumeWhitespace();\n        } else {\n          isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n        }\n      }\n    }\n  }, {\n    key: \"consumeMatch\",\n    value: function consumeMatch(re) {\n      var m = re.exec(this.fnString.substr(this.pos));\n      if (m) this.pos += m[0].length;\n      return m;\n    }\n    /**\n     * Advance the parser past an arbitrary regular expression. Return `token`,\n     * or the match object of the regexp.\n     */\n\n  }, {\n    key: \"consumeRegExp\",\n    value: function consumeRegExp(re, token) {\n      var m = re.exec(this.fnString.substr(this.pos));\n      if (!m) return;\n      this.pos += m[0].length;\n      this.consumeWhitespace();\n      return token;\n    }\n    /**\n     * Advance the parser past a template string.\n     */\n\n  }, {\n    key: \"consumeTemplate\",\n    value: function consumeTemplate() {\n      for (;;) {\n        this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n        if (this.fnString[this.pos] === \"`\") {\n          this.pos++;\n          this.consumeWhitespace();\n          return \"`\";\n        }\n\n        if (this.fnString.substr(this.pos, 2) === \"${\") {\n          this.pos += 2;\n          this.consumeWhitespace();\n          if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n        }\n\n        return;\n      }\n    }\n    /**\n     * Advance the parser past any whitespace or comments.\n     */\n\n  }, {\n    key: \"consumeWhitespace\",\n    value: function consumeWhitespace() {\n      this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n    }\n  }]);\n\n  return FunctionParser;\n}();\n\nexports.FunctionParser = FunctionParser;","map":{"version":3,"sources":["../src/function.ts"],"names":[],"mappings":"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","sourcesContent":["import { Next, ToString } from \"./types\";\nimport { quoteKey, isValidVariableName } from \"./quote\";\n\n/**\n * Used in function stringification.\n */\n/* istanbul ignore next */\nconst METHOD_NAMES_ARE_QUOTED =\n  {\n    \" \"() {\n      /* Empty. */\n    }\n  }[\" \"]\n    .toString()\n    .charAt(0) === '\"';\n\nconst FUNCTION_PREFIXES = {\n  Function: \"function \",\n  GeneratorFunction: \"function* \",\n  AsyncFunction: \"async function \",\n  AsyncGeneratorFunction: \"async function* \"\n};\n\nconst METHOD_PREFIXES = {\n  Function: \"\",\n  GeneratorFunction: \"*\",\n  AsyncFunction: \"async \",\n  AsyncGeneratorFunction: \"async *\"\n};\n\nconst TOKENS_PRECEDING_REGEXPS = new Set(\n  (\n    \"case delete else in instanceof new return throw typeof void \" +\n    \", ; : + - ! ~ & | ^ * / % < > ? =\"\n  ).split(\" \")\n);\n\n/**\n * Track function parser usage.\n */\nexport const USED_METHOD_KEY = new WeakSet<Function>();\n\n/**\n * Stringify a function.\n */\nexport const functionToString: ToString = (fn, space, next, key) => {\n  const name = typeof key === \"string\" ? key : undefined;\n\n  // Track in function parser for object stringify to avoid duplicate output.\n  if (name !== undefined) USED_METHOD_KEY.add(fn);\n\n  return new FunctionParser(fn, space, next, name).stringify();\n};\n\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\nexport function dedentFunction(fnString: string) {\n  let found: string | undefined;\n\n  for (const line of fnString.split(\"\\n\").slice(1)) {\n    const m = /^[\\s\\t]+/.exec(line);\n    if (!m) return fnString; // Early exit without indent.\n\n    const [str] = m;\n\n    if (found === undefined) found = str;\n    else if (str.length < found.length) found = str;\n  }\n\n  return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\n\n/**\n * Function parser and stringify.\n */\nexport class FunctionParser {\n  fnString: string;\n  fnType: keyof typeof FUNCTION_PREFIXES;\n  keyQuote: string | undefined;\n  keyPrefix: string;\n  isMethodCandidate: boolean;\n\n  pos = 0;\n  hadKeyword = false;\n\n  constructor(\n    public fn: Function,\n    public indent: string,\n    public next: Next,\n    public key?: string\n  ) {\n    this.fnString = Function.prototype.toString.call(fn);\n    this.fnType = fn.constructor.name as keyof typeof FUNCTION_PREFIXES;\n    this.keyQuote = key === undefined ? \"\" : quoteKey(key, next);\n    this.keyPrefix =\n      key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n    this.isMethodCandidate =\n      key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n  }\n\n  stringify() {\n    const value = this.tryParse();\n\n    // If we can't stringify this function, return a void expression; for\n    // bonus help with debugging, include the function as a string literal.\n    if (!value) {\n      return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n    }\n\n    return dedentFunction(value);\n  }\n\n  getPrefix() {\n    if (this.isMethodCandidate && !this.hadKeyword) {\n      return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n    }\n\n    return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n  }\n\n  tryParse() {\n    if (this.fnString[this.fnString.length - 1] !== \"}\") {\n      // Must be an arrow function.\n      return this.keyPrefix + this.fnString;\n    }\n\n    // Attempt to remove function prefix.\n    if (this.fn.name) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n    }\n\n    // Support class expressions.\n    const prevPos = this.pos;\n    if (this.consumeSyntax() === \"class\") return this.fnString;\n    this.pos = prevPos;\n\n    if (this.tryParsePrefixTokens()) {\n      const result = this.tryStrippingName();\n      if (result) return result;\n\n      let offset = this.pos;\n\n      switch (this.consumeSyntax(\"WORD_LIKE\")) {\n        case \"WORD_LIKE\":\n          if (this.isMethodCandidate && !this.hadKeyword) {\n            offset = this.pos;\n          }\n        // tslint:disable-next-line no-switch-case-fall-through\n        case \"()\":\n          if (this.fnString.substr(this.pos, 2) === \"=>\") {\n            return this.keyPrefix + this.fnString;\n          }\n\n          this.pos = offset;\n        // tslint:disable-next-line no-switch-case-fall-through\n        case '\"':\n        case \"'\":\n        case \"[]\":\n          return this.getPrefix() + this.fnString.substr(this.pos);\n      }\n    }\n  }\n\n  /**\n   * Attempt to parse the function from the current position by first stripping\n   * the function's name from the front. This is not a fool-proof method on all\n   * JavaScript engines, but yields good results on Node.js 4 (and slightly\n   * less good results on Node.js 6 and 8).\n   */\n  tryStrippingName() {\n    if (METHOD_NAMES_ARE_QUOTED) {\n      // ... then this approach is unnecessary and yields false positives.\n      return;\n    }\n\n    let start = this.pos;\n    const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n\n    if (prefix === this.fn.name) {\n      this.pos += prefix.length;\n\n      if (\n        this.consumeSyntax() === \"()\" &&\n        this.consumeSyntax() === \"{}\" &&\n        this.pos === this.fnString.length\n      ) {\n        // Don't include the function's name if it will be included in the\n        // prefix, or if it's invalid as a name in a function expression.\n        if (this.isMethodCandidate || !isValidVariableName(prefix)) {\n          start += prefix.length;\n        }\n\n        return this.getPrefix() + this.fnString.substr(start);\n      }\n    }\n\n    this.pos = start;\n  }\n\n  /**\n   * Attempt to advance the parser past the keywords expected to be at the\n   * start of this function's definition. This method sets `this.hadKeyword`\n   * based on whether or not a `function` keyword is consumed.\n   *\n   * @return {boolean}\n   */\n  tryParsePrefixTokens() {\n    let posPrev = this.pos;\n\n    this.hadKeyword = false;\n\n    switch (this.fnType) {\n      case \"AsyncFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n\n        posPrev = this.pos;\n      // tslint:disable-next-line no-switch-case-fall-through\n      case \"Function\":\n        if (this.consumeSyntax() === \"function\") {\n          this.hadKeyword = true;\n        } else {\n          this.pos = posPrev;\n        }\n        return true;\n      case \"AsyncGeneratorFunction\":\n        if (this.consumeSyntax() !== \"async\") return false;\n      // tslint:disable-next-line no-switch-case-fall-through\n      case \"GeneratorFunction\":\n        let token = this.consumeSyntax();\n\n        if (token === \"function\") {\n          token = this.consumeSyntax();\n          this.hadKeyword = true;\n        }\n\n        return token === \"*\";\n    }\n  }\n\n  /**\n   * Advance the parser past one element of JavaScript syntax. This could be a\n   * matched pair of delimiters, like braces or parentheses, or an atomic unit\n   * like a keyword, variable, or operator. Return a normalized string\n   * representation of the element parsed--for example, returns '{}' for a\n   * matched pair of braces. Comments and whitespace are skipped.\n   *\n   * (This isn't a full parser, so the token scanning logic used here is as\n   * simple as it can be. As a consequence, some things that are one token in\n   * JavaScript, like decimal number literals or most multicharacter operators\n   * like '&&', are split into more than one token here. However, awareness of\n   * some multicharacter sequences like '=>' is necessary, so we match the few\n   * of them that we care about.)\n   */\n  consumeSyntax(wordLikeToken?: string) {\n    const m = this.consumeMatch(\n      /^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/\n    );\n\n    if (!m) return;\n\n    const [token, match] = m;\n    this.consumeWhitespace();\n\n    if (match) return wordLikeToken || match;\n\n    switch (token) {\n      case \"(\":\n        return this.consumeSyntaxUntil(\"(\", \")\");\n      case \"[\":\n        return this.consumeSyntaxUntil(\"[\", \"]\");\n      case \"{\":\n        return this.consumeSyntaxUntil(\"{\", \"}\");\n      case \"`\":\n        return this.consumeTemplate();\n      case '\"':\n        return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n      case \"'\":\n        return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n    }\n\n    return token;\n  }\n\n  consumeSyntaxUntil(startToken: string, endToken: string): string | undefined {\n    let isRegExpAllowed = true;\n\n    for (;;) {\n      const token = this.consumeSyntax();\n      if (token === endToken) return startToken + endToken;\n      if (!token || token === \")\" || token === \"]\" || token === \"}\") return;\n\n      if (\n        token === \"/\" &&\n        isRegExpAllowed &&\n        this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)\n      ) {\n        isRegExpAllowed = false;\n        this.consumeWhitespace();\n      } else {\n        isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n      }\n    }\n  }\n\n  consumeMatch(re: RegExp) {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (m) this.pos += m[0].length;\n    return m;\n  }\n\n  /**\n   * Advance the parser past an arbitrary regular expression. Return `token`,\n   * or the match object of the regexp.\n   */\n  consumeRegExp(re: RegExp, token: string): string | undefined {\n    const m = re.exec(this.fnString.substr(this.pos));\n    if (!m) return;\n    this.pos += m[0].length;\n    this.consumeWhitespace();\n    return token;\n  }\n\n  /**\n   * Advance the parser past a template string.\n   */\n  consumeTemplate() {\n    for (;;) {\n      this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n\n      if (this.fnString[this.pos] === \"`\") {\n        this.pos++;\n        this.consumeWhitespace();\n        return \"`\";\n      }\n\n      if (this.fnString.substr(this.pos, 2) === \"${\") {\n        this.pos += 2;\n        this.consumeWhitespace();\n\n        if (this.consumeSyntaxUntil(\"{\", \"}\")) continue;\n      }\n\n      return;\n    }\n  }\n\n  /**\n   * Advance the parser past any whitespace or comments.\n   */\n  consumeWhitespace() {\n    this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}