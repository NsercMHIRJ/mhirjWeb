{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/kanu/Desktop/MHIRJTEST/mhirjWeb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/kanu/Desktop/MHIRJTEST/mhirjWeb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar stringify_1 = require(\"./stringify\");\n\nvar quote_1 = require(\"./quote\");\n/**\n * Root path node.\n */\n\n\nvar ROOT_SENTINEL = Symbol(\"root\");\n/**\n * Stringify any JavaScript value.\n */\n\nfunction stringify(value, replacer, indent) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  var path = [];\n  var stack = new Set();\n  var tracking = new Map();\n  var unpack = new Map();\n  var valueCount = 0;\n  var _options$maxDepth = options.maxDepth,\n      maxDepth = _options$maxDepth === void 0 ? 100 : _options$maxDepth,\n      _options$references = options.references,\n      references = _options$references === void 0 ? false : _options$references,\n      _options$skipUndefine = options.skipUndefinedProperties,\n      skipUndefinedProperties = _options$skipUndefine === void 0 ? false : _options$skipUndefine,\n      _options$maxValues = options.maxValues,\n      maxValues = _options$maxValues === void 0 ? 100000 : _options$maxValues; // Wrap replacer function to support falling back on supported stringify.\n\n  var valueToString = replacerToString(replacer); // Every time you call `next(value)` execute this function.\n\n  var onNext = function onNext(value, key) {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return; // An undefined key is treated as an out-of-band \"value\".\n\n    if (key === undefined) return valueToString(value, space, onNext, key);\n    path.push(key);\n    var result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  var builder = references ? function (value, key) {\n    if (value !== null && (typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\")) {\n      // Track nodes to restore later.\n      if (tracking.has(value)) {\n        unpack.set(path.slice(1), tracking.get(value));\n        return; // Avoid serializing referenced nodes on an expression.\n      } // Track encountered nodes.\n\n\n      tracking.set(value, path.slice(1));\n    }\n\n    return valueToString(value, space, onNext, key);\n  } : function (value, key) {\n    // Stop on recursion.\n    if (stack.has(value)) return;\n    stack.add(value);\n    var result = valueToString(value, space, onNext, key);\n    stack.delete(value);\n    return result;\n  };\n  var result = onNext(value, ROOT_SENTINEL); // Attempt to restore circular references.\n\n  if (unpack.size) {\n    var sp = space ? \" \" : \"\";\n    var eol = space ? \"\\n\" : \"\";\n    var wrapper = \"var x\".concat(sp, \"=\").concat(sp).concat(result, \";\").concat(eol);\n\n    var _iterator = _createForOfIteratorHelper(unpack.entries()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            _value = _step$value[1];\n\n        var keyPath = quote_1.stringifyPath(key, onNext);\n        var valuePath = quote_1.stringifyPath(_value, onNext);\n        wrapper += \"x\".concat(keyPath).concat(sp, \"=\").concat(sp, \"x\").concat(valuePath, \";\").concat(eol);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return \"(function\".concat(sp, \"()\").concat(sp, \"{\").concat(eol).concat(wrapper, \"return x;\").concat(eol, \"}())\");\n  }\n\n  return result;\n}\n\nexports.stringify = stringify;\n/**\n * Create `toString()` function from replacer.\n */\n\nfunction replacerToString(replacer) {\n  if (!replacer) return stringify_1.toString;\n  return function (value, space, next, key) {\n    return replacer(value, space, function (value) {\n      return stringify_1.toString(value, space, next, key);\n    }, key);\n  };\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { toString } from \"./stringify\";\nimport { stringifyPath } from \"./quote\";\nimport { Next, ToString } from \"./types\";\n\nexport interface Options {\n  maxDepth?: number;\n  maxValues?: number;\n  references?: boolean;\n  skipUndefinedProperties?: boolean;\n}\n\n/**\n * Root path node.\n */\nconst ROOT_SENTINEL = Symbol(\"root\");\n\n/**\n * Stringify any JavaScript value.\n */\nexport function stringify(\n  value: any,\n  replacer?: ToString | null,\n  indent?: string | number | null,\n  options: Options = {}\n) {\n  const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n  const path: PropertyKey[] = [];\n  const stack = new Set();\n  const tracking = new Map<any, PropertyKey[]>();\n  const unpack = new Map<PropertyKey[], PropertyKey[]>();\n  let valueCount = 0;\n\n  const {\n    maxDepth = 100,\n    references = false,\n    skipUndefinedProperties = false,\n    maxValues = 100000\n  } = options;\n\n  // Wrap replacer function to support falling back on supported stringify.\n  const valueToString = replacerToString(replacer);\n\n  // Every time you call `next(value)` execute this function.\n  const onNext: Next = (value, key) => {\n    if (++valueCount > maxValues) return;\n    if (skipUndefinedProperties && value === undefined) return;\n    if (path.length > maxDepth) return;\n\n    // An undefined key is treated as an out-of-band \"value\".\n    if (key === undefined) return valueToString(value, space, onNext, key);\n\n    path.push(key);\n    const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n    path.pop();\n    return result;\n  };\n\n  const builder: Next = references\n    ? (value, key) => {\n        if (\n          value !== null &&\n          (typeof value === \"object\" ||\n            typeof value === \"function\" ||\n            typeof value === \"symbol\")\n        ) {\n          // Track nodes to restore later.\n          if (tracking.has(value)) {\n            unpack.set(path.slice(1), tracking.get(value)!);\n            return; // Avoid serializing referenced nodes on an expression.\n          }\n\n          // Track encountered nodes.\n          tracking.set(value, path.slice(1));\n        }\n\n        return valueToString(value, space, onNext, key);\n      }\n    : (value, key) => {\n        // Stop on recursion.\n        if (stack.has(value)) return;\n\n        stack.add(value);\n        const result = valueToString(value, space, onNext, key);\n        stack.delete(value);\n        return result;\n      };\n\n  const result = onNext(value, ROOT_SENTINEL);\n\n  // Attempt to restore circular references.\n  if (unpack.size) {\n    const sp = space ? \" \" : \"\";\n    const eol = space ? \"\\n\" : \"\";\n    let wrapper = `var x${sp}=${sp}${result};${eol}`;\n\n    for (const [key, value] of unpack.entries()) {\n      const keyPath = stringifyPath(key, onNext);\n      const valuePath = stringifyPath(value, onNext);\n\n      wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n    }\n\n    return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n  }\n\n  return result;\n}\n\n/**\n * Create `toString()` function from replacer.\n */\nfunction replacerToString(replacer?: ToString | null): ToString {\n  if (!replacer) return toString;\n\n  return (value, space, next, key) => {\n    return replacer(\n      value,\n      space,\n      (value: any) => toString(value, space, next, key),\n      key\n    );\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}